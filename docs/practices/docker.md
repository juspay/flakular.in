---
slug: /docker
---

# Building a docker image

Building a docker image is much simpler with Nix compared to writing `Dockerfile`. Since the entire build process is handled by Nix flakes, most of what's left to do for docker image creation is copying of the derivations and configuration.

## Writing the Nix to build the docker image

Consider a haskell-flake project "foo". To copy the binaries generated by the `default` package to `/bin` on the image,  one can use `copyToRoot` attribute offered by [`dockerTools.buildImage`](https://nixos.org/manual/nixpkgs/stable/#sec-pkgs-dockerTools). For example:

```nix
{
  # Inside perSystem
  packages.dockerImage = pkgs.dockerTools.buildImage {
    name = "foo";
    copyToRoot = pkgs.buildEnv {
      paths = with pkgs; [
        self'.packages.default
      ];
      name = "foo-root";
      pathsToLink = [ "/bin" ];
    };
  };
}
```

In addition to copying over the flake `packages`, we may also copy *paths* in the project. `self` can be added to `paths` to expose the project directory. 
```nix
{
  copyToRoot = pkgs.buildEnv {
    paths = with pkgs; [
      coreutils
      bash
      self
    ];
    name = "foo-root";
    pathsToLink = [ "/foo_sub" "/bin" ];
  };
}
```
If you'd like your docker image to run your haskell project's default package when the container starts, use the following config:
```nix
{
  # Inside dockerImage's `buildImage`
  config = {
    Cmd = [ "${pkgs.lib.getExe self'.packages.default}" ];
  };
}
```

## Build the docker image

To build the docker image *as a Nix derivation*, run:

```bash
nix build .#dockerImage
```

To load this image into your local docker image registry, run:

```bash
docker load -i $(nix build .#dockerImage --print-out-paths)
```

## Tips

### Size

Packages in `self'.packages` are shipped with symlinks to other store paths, like `$out/lib`, `$out/nix-support` and `$out/share/doc`. Along with these, enabling profiling or haddock can also increase the size of the package that you ship. Thus, you will want to strip all but the executables before copying the package to the docker image. This can be achieved using `justStaticExecutables`:

```nix
  # Inside perSystem
  packages.default = pkgs.haskell.lib.justStaticExecutables self'.packages.foo;
```

### Size caveats

There can be cases where `justStaticExecutables` doesn't work. In such cases, you can manually remove references to the store paths that you don't want to ship. Let's say you have a haskell project `foo` that is dependendent on `bar` and `bar`
relies on `data-files` in its cabal. These `data-files` can be `js` or `html` files for instances. Considering you are using `cabal-install < 3.10.1.0` the final executable of `foo` will have a reference to `bar` and `bar` will depend on `ghc`, thus increasing the overal size of the docker image. But how do you arrive at this point in the first place? i.e how do you pin point the exact store paths that are causing the increase in size? These are the rough steps that you can follow:
- Build and scan the docker image for store paths that are taking up the most space:
  ```bash
  nix build .#dockerImage
  docker load -i < result
  docker run --rm -it <name:tag> sh -c 'du -sh /nix/store/*' | sort -h | tail
  ```
- After the scan you will notice that `bar` will be present and its quite obvious it shouldn't be present because all of that will be packaged in the executable of `foo`. 

- It might not be obvious to you that `bar` is causing the increase in size. In such cases you can use `nix why-depends` to find out why `ghc` is present in the docker image:
  ```bash
  nix why-depends /nix/store/...-foo /nix/store/...-ghc-x.x.x
  ```

- Now that you know that `bar` is causing the increase in size, let's wrap the executable of `foo` [removing references to](https://srid.ca/remove-references-to) `bar`:
```nix
{
  # Inside `haskellProjects`
  haskellProjects.default = 
    let
      # Forked from: https://github.com/srid/emanote/blob/24c7e5e29a91ec201a48fad1ac028a123b82a402/flake.nix#L52-L62
      # We shouldn't need this after https://github.com/haskell/cabal/pull/8534
      removeReferencesTo = disallowedReferences: drv:
        drv.overrideAttrs (old: rec {
          inherit disallowedReferences;
          # Ditch data dependencies that are not needed at runtime.
          # cf. https://github.com/NixOS/nixpkgs/pull/204675
          # cf. https://srid.ca/remove-references-to
          postInstall = (old.postInstall or "") + ''
            ${lib.concatStrings (map (e: "echo Removing reference to: ${e}\n") disallowedReferences)}
            ${lib.concatStrings (map (e: "remove-references-to -t ${e} $out/bin/*\n") disallowedReferences)}
          '';
        });
    in
    {
      # ...
      settings = {
        foo = {self, super, ... }: {
          justStaticExecutables = true;
          removeReferencesTo = [
            self.bar
          ];
        };
      };
      # ...
    };
}
```
- Voila! Now you have a docker image that is much smaller than before.

### Time

If you don't want `docker images` showing that the image was created several decades ago, use the following:
```nix
{
  # Inside perSystem.packages' `dockerImage`:
  pkgs.dockerTools.buildImage {
    name = "foo";
    created = "now";
  };
}
```

### Tag

If you want to tag the images with the commit id of the working copy:

```nix
{
  # Inside perSystem.packages' `dockerImage`:
  pkgs.dockerTools.buildImage {
    name = "foo";
    tag = builtins.substring 0 9 (self.rev or "dev");
  };
}
```
[`builtins.substring 0 9 self.rev`](https://nixos.org/manual/nix/stable/language/builtins.html#builtins-substring) is the same as `git rev-parse --short HEAD`. `self.rev` is non-null only on a clean working copy and hence the tag is set to `dev` when the working copy is dirty.

### SSL certs

In order to be able to make https connections from inside of the docker image, you must expose the cacert Nix package via the relevant environment variable:

```nix
{
  # Inside dockerTools.buildImage
  config = {
    Env = [ 
      "SSL_CERT_FILE=${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt" 
      # Ref: https://hackage.haskell.org/package/x509-system-1.6.7/docs/src/System.X509.Unix.html#getSystemCertificateStore
      "SYSTEM_CERTIFICATE_PATH=${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt"
    ];
  };
}
```


## Example

- [Sample flake-parts module for docker](https://github.com/nammayatri/nammayatri/pull/14/files#diff-18ea3dd9a6a84702796b8dac608d0cad8e396a7c2e8c52732fcb7e5f52d1b0b9)
