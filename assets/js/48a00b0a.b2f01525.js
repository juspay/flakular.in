"use strict";(self.webpackChunkzero_to_flakes=self.webpackChunkzero_to_flakes||[]).push([[125],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},d="mdxType",k={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},u=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(t),u=i,m=d["".concat(s,".").concat(u)]||d[u]||k[u]||r;return t?a.createElement(m,l(l({ref:n},c),{},{components:t})):a.createElement(m,l({ref:n},c))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=u;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o[d]="string"==typeof e?e:i,l[1]=o;for(var p=2;p<r;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},6116:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>k,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var a=t(7462),i=(t(7294),t(3905));const r={slug:"/haskell/dependency"},l="Overriding dependencies",o={unversionedId:"modules/haskell/guide/dependency",id:"modules/haskell/guide/dependency",title:"Overriding dependencies",description:"Haskell libraries ultimately come from Hackage, and nixpkgs] contains [most of these. Adding a library to your project usually involves modifying the .cabal file and restart the nix shell:",source:"@site/docs/modules/haskell/guide/dependency.md",sourceDirName:"modules/haskell/guide",slug:"/haskell/dependency",permalink:"/haskell/dependency",draft:!1,editUrl:"https://github.com/juspay/zero-to-flakes/tree/main/docs/modules/haskell/guide/dependency.md",tags:[],version:"current",frontMatter:{slug:"/haskell/dependency"},sidebar:"tutorialSidebar",previous:{title:"Guide",permalink:"/haskell/guide"},next:{title:"DevShell",permalink:"/haskell/devshell"}},s={},p=[{value:"Overriding a Haskell package in Nix",id:"overriding-a-haskell-package-in-nix",level:2},{value:"nixpkgs functions",id:"nixpkgs-functions",level:3},{value:"Using Hackage versions",id:"using-hackage-versions",level:2},{value:"Exporting and sharing settings",id:"exporting-and-sharing-settings",level:2},{value:"Examples",id:"examples",level:2}],c={toc:p},d="wrapper";function k(e){let{components:n,...t}=e;return(0,i.kt)(d,(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"overriding-dependencies"},"Overriding dependencies"),(0,i.kt)("p",null,"Haskell libraries ultimately come from ",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/"},"Hackage"),", and ",(0,i.kt)("a",{parentName:"p",href:"https://zero-to-nix.com/concepts/nixpkgs"},"nixpkgs")," contains ",(0,i.kt)("a",{parentName:"p",href:"https://nixpkgs.haskell.page/"},"most of these"),". Adding a library to your project usually involves modifying the ",(0,i.kt)("inlineCode",{parentName:"p"},".cabal")," file and restart the nix shell:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Identify the package name from Hackage. Let's say you want to use ",(0,i.kt)("a",{parentName:"li",href:"https://hackage.haskell.org/package/ema"},(0,i.kt)("inlineCode",{parentName:"a"},"ema"))),(0,i.kt)("li",{parentName:"ol"},"Add the package, ",(0,i.kt)("inlineCode",{parentName:"li"},"ema"),", to the ",(0,i.kt)("inlineCode",{parentName:"li"},".cabal")," file under ",(0,i.kt)("a",{parentName:"li",href:"https://cabal.readthedocs.io/en/3.4/cabal-package.html#pkg-field-build-depends"},"the ",(0,i.kt)("inlineCode",{parentName:"a"},"build-depends")," section"),"."),(0,i.kt)("li",{parentName:"ol"},"Exit and restart the nix shell (",(0,i.kt)("inlineCode",{parentName:"li"},"nix develop"),"). ")),(0,i.kt)("p",null,"Step (3) above will try to fetch the package from the Haskell package set in ",(0,i.kt)("a",{parentName:"p",href:"https://zero-to-nix.com/concepts/nixpkgs"},"nixpkgs")," (the one that is pinned in ",(0,i.kt)("inlineCode",{parentName:"p"},"flake.lock"),"). For various reasons, this package may be either missing or marked as broken. In such cases, you will have to override the package locally in the project (see the next section)."),(0,i.kt)("h2",{id:"overriding-a-haskell-package-in-nix"},"Overriding a Haskell package in Nix"),(0,i.kt)("p",null,"In Nix, it is possible to use an exact package built from an arbitrary source (Git repo or local directory). If you want to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"master")," branch of the ",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/ema"},"ema")," library, for instance, you can do it as follows:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Add a flake input pointing to the ema Git repo in ",(0,i.kt)("inlineCode",{parentName:"li"},"flake.nix"),": ",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-nix"},'{\n  inputs = {\n    ema.url = "github:srid/ema";\n    ema.flake = false;\n  };\n}\n'))),(0,i.kt)("li",{parentName:"ol"},"Build it using ",(0,i.kt)("inlineCode",{parentName:"li"},"callCabal2nix")," and assign it to the ",(0,i.kt)("inlineCode",{parentName:"li"},"ema")," name in the Haskell package set by adding it to the ",(0,i.kt)("inlineCode",{parentName:"li"},"packages")," argument of your ",(0,i.kt)("inlineCode",{parentName:"li"},"flake.nix")," that is using haskell-flake:",(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-nix"},"{\n  perSystem = { self', config, pkgs, ... }: {\n    haskellProjects.default = {\n      packages = {\n        ema.source = inputs.ema;\n      };\n      settings = {\n        ema = {  # This module can take `{self, super, ...}` args, optionally.\n          check = false;     # Disable running tests\n          haddock = false;   # Disable building haddock documentation\n          jailbreak = true;  # Ignore cabal constraints\n          patches = [ ./patches/ema-bug-fix.patch ];\n          cabalFlags.with-generics = true;\n        };\n      };\n    };\n  };\n}\n"))),(0,i.kt)("li",{parentName:"ol"},"Re-run the nix shell (",(0,i.kt)("inlineCode",{parentName:"li"},"nix develop"),").")),(0,i.kt)("h3",{id:"nixpkgs-functions"},(0,i.kt)("a",{parentName:"h3",href:"https://zero-to-nix.com/concepts/nixpkgs"},"nixpkgs")," functions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"pkgs.haskell.lib")," module provides various utility functions that you can use to override Haskell packages. The canonical place to find documentation on these is ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/haskell-modules/lib/compose.nix"},"the source"),". haskell-flake provides a ",(0,i.kt)("inlineCode",{parentName:"li"},"settings")," submodule for convienience; for eg., the ",(0,i.kt)("inlineCode",{parentName:"li"},"dontCheck")," function translates to ",(0,i.kt)("inlineCode",{parentName:"li"},"settings.<name>.check"),".")),(0,i.kt)("h2",{id:"using-hackage-versions"},"Using Hackage versions"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"packages.<name>.source")," also supports Hackage versions. So the following works to pull ",(0,i.kt)("a",{parentName:"p",href:"https://hackage.haskell.org/package/ema-0.8.2.0"},"ema 0.8.2.0"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-nix"},'{\n  perSystem = { self\', config, pkgs, ... }: {\n    haskellProjects.default = {\n      packages = {\n        ema.source = "0.8.2.0";\n      };\n    };\n  };\n}\n')),(0,i.kt)("h2",{id:"exporting-and-sharing-settings"},"Exporting and sharing settings"),(0,i.kt)("p",null,"[","[modules]","] export both ",(0,i.kt)("inlineCode",{parentName:"p"},"packages")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"settings")," options for reuse in downstream Haskell projects."),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/srid/emanote/commit/5b24bd04f94e03afe66ee01da723e4a05d854953"},"Emanote overrides"),": also demonstrates how to add a ",(0,i.kt)("em",{parentName:"li"},"new")," setting option (",(0,i.kt)("inlineCode",{parentName:"li"},"removeReferencesTo"),").")))}k.isMDXComponent=!0}}]);